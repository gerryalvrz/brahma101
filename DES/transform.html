<html><head><base href="https://websim.ai/shaders/" />
  <style>body, html {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-family: 'Courier New', monospace; /* Hacker aesthetic */
    background-color: #000; /* Black background */
    color: #0f0; /* Green glow aesthetic */
  }
  
  canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
  
  #customizeMenu {
    position: absolute;
    top: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.85); /* Darker background */
    color: #0f0; /* Green glow aesthetic */
    padding: 20px;
    border-radius: 10px;
    display: none; /* Explicitly hidden by default */
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 0 15px #0f0; /* Glow effect */
    border: 1px solid #0f0;
  }
  
  #toggleMenu {
    position: absolute;
    top: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.85); /* Darker button background */
    color: #0f0; /* Green text */
    border: 1px solid #0f0;
    padding: 10px;
    cursor: pointer;
    border-radius: 5px;
    box-shadow: 0 0 5px #0f0; /* Subtle glow */
    transition: box-shadow 0.3s, transform 0.2s;
  }
  
  #toggleMenu:hover {
    box-shadow: 0 0 15px #0f0; /* More intense glow */
    transform: scale(1.1); /* Slight zoom */
  }
  
  #randomizeButton {
    position: absolute;
    bottom: 20px;
    left: 20px; /* Changed from 1280px to 20px for mobile compatibility */
    background: rgba(0, 0, 0, 0.85); /* Darker button background */
    color: #0f0; /* Green text */
    border: 1px solid #0f0;
    padding: 10px 20px;
    cursor: pointer;
    border-radius: 5px;
    box-shadow: 0 0 5px #0f0; /* Subtle glow */
    transition: box-shadow 0.3s, transform 0.2s;
  }
  
  #randomizeButton:hover {
    box-shadow: 0 0 15px #0f0; /* More intense glow */
    transform: scale(1.1); /* Slight zoom */
  }
  
  input[type="range"] {
    width: 100%;
    margin: 10px 0;
    background: #000;
    outline: none;
    -webkit-appearance: none;
    appearance: none;
  }
  
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    background: #0f0;
    cursor: pointer;
    border-radius: 50%;
    box-shadow: 0 0 5px #0f0; /* Glow effect */
    transition: box-shadow 0.3s;
  }
  
  input[type="range"]::-webkit-slider-thumb:hover {
    box-shadow: 0 0 10px #0f0; /* Intense glow on hover */
  }
  
  label {
    display: block;
    margin-top: 15px;
    color: #0f0; /* Green text */
  }
  
  .color-picker {
    display: flex;
    align-items: center;
    margin-top: 15px;
  }
  
  .color-picker input[type="color"] {
    margin-right: 10px;
    width: 40px;
    height: 40px;
    border: none;
    border-radius: 50%;
    box-shadow: 0 0 5px #0f0; /* Glow effect */
    transition: box-shadow 0.3s;
  }
  
  .color-picker input[type="color"]:hover {
    box-shadow: 0 0 10px #0f0; /* Intense glow on hover */
  }
  
  #closeMenu {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0, 0, 0, 0.85);
    color: #0f0; /* Green glow aesthetic */
    border: none;
    padding: 10px;
    cursor: pointer;
    border-radius: 5px;
    box-shadow: 0 0 5px #0f0;
    transition: box-shadow 0.3s, transform 0.2s;
  }
  
  #closeMenu:hover {
    box-shadow: 0 0 15px #0f0; /* Intense glow */
    transform: scale(1.1); /* Slight zoom */
  }
  
  /* Mobile Responsive Design */
  @media screen and (max-width: 768px) {
    #shaderContainer {
      top: 100px; /* More space for buttons */
      bottom: 80px; /* Space for bottom button */
      left: 10px;
      right: 10px; /* Full width on mobile */
    }
    
    #toggleMenu {
      top: 20px;
      right: 10px;
      padding: 12px 15px;
      font-size: 14px;
    }
    
    #randomizeButton {
      bottom: 20px;
      left: 10px;
      right: 10px; /* Full width button on mobile */
      padding: 12px 15px;
      font-size: 14px;
      text-align: center;
    }
    
    #customizeMenu {
      top: 10px;
      right: 10px;
      left: 10px; /* Full width menu on mobile */
      max-height: 70vh;
      padding: 15px;
    }
    
    .color-picker {
      flex-direction: column;
      align-items: flex-start;
      margin-top: 10px;
    }
    
    .color-picker input[type="color"] {
      margin-bottom: 5px;
    }
    
    input[type="range"] {
      margin: 8px 0;
    }
    
    label {
      margin-top: 10px;
      font-size: 14px;
    }
  }
  

  </style>
  </head>
  <body>
    <header>
      <h1>Generative Art</h1>
    </header>
    <div id="shaderContainer">
      <canvas id="shaderCanvas"></canvas>
    </div>
    
    <style>
   #shaderContainer {
    position: absolute;
    top: 50px;
    bottom: 20px;
    left: 20px;
    right: 20px; /* Changed from 300px to 20px for better mobile compatibility */
    background: rgba(0, 50, 0, 0.85); /* Semi-transparent green background */
    border: 2px solid #0f0; /* Glowing green border */
    border-radius: 10px; /* Rounded corners */
    overflow: hidden; /* Prevent content overflow */
    box-shadow: 0 0 15px #0f0; /* Glow effect */
  }
    
      #shaderCanvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      #toggleMenu {
    position: absolute;
    top: 60px;
    right: 20px;
    background: rgba(0, 0, 0, 0.85); /* Darker button background */
    color: #0f0; /* Green text */
    border: 1px solid #0f0;
    padding: 10px;
    cursor: pointer;
    border-radius: 5px;
    box-shadow: 0 0 5px #0f0; /* Subtle glow */
    transition: box-shadow 0.3s, transform 0.2s;
  }

  #toggleMenu:hover {
    box-shadow: 0 0 15px #0f0; /* More intense glow */
    transform: scale(1.1); /* Slight zoom */
  }

  #randomizeButton:hover {
    box-shadow: 0 0 15px #0f0; /* More intense glow */
    transform: scale(1.1); /* Slight zoom */
  }

    </style>
    
  <button id="toggleMenu">Customize Shader</button>
  <button id="randomizeButton">Randomize Shader</button>
  <div id="customizeMenu">
    <button id="closeMenu">X</button>
    <h3>Transform</h3>
    <label for="speed">Animation Speed:</label>
    <input type="range" id="speed" min="0" max="2" step="0.1" value="0.5">
    <label for="iterations">Iterations:</label>
    <input type="range" id="iterations" min="1" max="10" step="1" value="5">
    <label for="colorShift">Color Shift:</label>
    <input type="range" id="colorShift" min="0" max="1" step="0.1" value="0.6">
    <label for="zoom">Zoom:</label>
    <input type="range" id="zoom" min="0.5" max="2" step="0.1" value="1.2">
    <label for="mirrors">Number of Mirrors:</label>
    <input type="range" id="mirrors" min="2" max="32" step="1" value="6">
    
    <h4>Color Palette:</h4>
    <div class="color-picker">
      <input type="color" id="color1" value="#80CCFF">
      <label for="color1">Color 1</label>
    </div>
    <div class="color-picker">
      <input type="color" id="color2" value="#3399CC">
      <label for="color2">Color 2</label>
    </div>
    <div class="color-picker">
      <input type="color" id="color3" value="#FFFFFF">
      <label for="color3">Color 3</label>
    </div>
    <div class="color-picker">
      <input type="color" id="color4" value="#193D99">
      <label for="color4">Color 4</label>
    </div>
  </div>
  
  <script id="vertexShader" type="x-shader/x-vertex">
    attribute vec4 aVertexPosition;
    void main() {
      gl_Position = aVertexPosition;
    }
  </script>
  <script id="fragmentShader" type="x-shader/x-fragment">
    precision highp float;
    uniform vec2 uResolution;
    uniform float uTime;
    uniform float uIterations;
    uniform float uColorShift;
    uniform float uZoom;
    uniform vec3 uColor1;
    uniform vec3 uColor2;
    uniform vec3 uColor3;
    uniform vec3 uColor4;
    uniform float uMirrors;
  
    vec3 palette(float t) {
      vec3 a = uColor1;
      vec3 b = uColor2;
      vec3 c = uColor3;
      vec3 d = uColor4;
      return a + b*cos( 6.28318*(c*t+d) );
    }
  
    float fluid(vec2 p) {
      float t = uTime * 0.4;
      vec2 pos = p * 3.0;
      float v = 0.0;
      float tm = t * 0.2;
      
      v += sin(pos.x * 1.1 + tm + sin(pos.y * 0.5 + t * 0.8) * 2.0);
      v += sin(pos.y * 1.2 + tm + sin(pos.x * 0.6 + t * 0.7) * 2.0);
      v += sin(pos.x * 0.9 + pos.y * 0.8 + tm + sin(t * 0.5) * 2.0);
      
      float tx = pos.x * 3.0 + v * 0.5 + t;
      float ty = pos.y * 3.0 + t * 0.4;
      float vx = sin(tx + ty);
      float vy = sin(tx - ty);
      
      return v + vx * vy;
  }
  
    void main() {
      vec2 uv = (gl_FragCoord.xy * 2.0 - uResolution.xy) / uResolution.y;
      uv *= uZoom;
      
      float angle = atan(uv.y, uv.x);
      float radius = length(uv);
      float sector = 6.28318 / uMirrors;
      angle = mod(angle, sector);
      if (mod(floor(atan(uv.y, uv.x) / sector), 2.0) == 1.0) {
        angle = sector - angle;
      }
      uv = vec2(cos(angle), sin(angle)) * radius;
      
      vec2 uv0 = uv;
      vec3 finalColor = vec3(0.0);
      
      for (float i = 0.0; i < 10.0; i++) {
        if (i >= uIterations) break;
        
        vec2 fluidUv = uv;
        float f = fluid(fluidUv);
        uv = fract(uv * 1.5 + f * 0.1) - 0.5;
        
        float d = length(uv) * exp(-length(uv0));
        
        vec3 col = palette(length(uv0) + i*uColorShift + f * 0.2);
        
        d = sin(d*8. + f*2.)/8.;
        d = abs(d);
        
        d = pow(0.01 / d, 1.2);
        
        finalColor += col * d;
      }
      
      float glow = fluid(uv0 * 0.5) * 0.1;
      finalColor += palette(glow) * glow;
      
      gl_FragColor = vec4(finalColor, 1.0);
    }
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
  <script>
    const canvas = document.getElementById('shaderCanvas');
    const gl = canvas.getContext('webgl');
  
    
    if (!gl) {
      console.error('WebGL not supported');
      document.body.innerHTML = 'WebGL is not supported in your browser.';
    }
  
    function compileShader(gl, shaderSource, shaderType) {
      const shader = gl.createShader(shaderType);
      gl.shaderSource(shader, shaderSource);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(shader));
      }
      return shader;
    }
  
    function createProgram(gl, vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(program));
      }
      return program;
    }
  
    const vertexShaderSource = document.getElementById('vertexShader').textContent;
    const fragmentShaderSource = document.getElementById('fragmentShader').textContent;
  
    const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
    const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
    const program = createProgram(gl, vertexShader, fragmentShader);
  
    const positionAttributeLocation = gl.getAttribLocation(program, 'aVertexPosition');
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
  
    const resolutionUniformLocation = gl.getUniformLocation(program, 'uResolution');
    const timeUniformLocation = gl.getUniformLocation(program, 'uTime');
    const iterationsUniformLocation = gl.getUniformLocation(program, 'uIterations');
    const colorShiftUniformLocation = gl.getUniformLocation(program, 'uColorShift');
    const zoomUniformLocation = gl.getUniformLocation(program, 'uZoom');
    const color1UniformLocation = gl.getUniformLocation(program, 'uColor1');
    const color2UniformLocation = gl.getUniformLocation(program, 'uColor2');
    const color3UniformLocation = gl.getUniformLocation(program, 'uColor3');
    const color4UniformLocation = gl.getUniformLocation(program, 'uColor4');
    const mirrorsUniformLocation = gl.getUniformLocation(program, 'uMirrors');
  
    function resizeCanvasToDisplaySize(canvas) {
      const displayWidth  = canvas.clientWidth;
      const displayHeight = canvas.clientHeight;
      if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
        canvas.width  = displayWidth;
        canvas.height = displayHeight;
      }
    }
  
    let speed = 0.5;  
    let iterations = 5;
    let colorShift = 0.6;
    let zoom = 1.2;
    let mirrors = 6;
    let color1 = [0.5, 0.8, 1.0];  
    let color2 = [0.2, 0.5, 0.8];  
    let color3 = [1.0, 1.0, 1.0];  
    let color4 = [0.1, 0.3, 0.7];  
  
    function hexToRgb(hex) {
      const r = parseInt(hex.slice(1, 3), 16) / 255;
      const g = parseInt(hex.slice(3, 5), 16) / 255;
      const b = parseInt(hex.slice(5, 7), 16) / 255;
      return [r, g, b];
    }
  
    function rgbToHex(r, g, b) {
      return "#" + ((1 << 24) + (Math.round(r * 255) << 16) + (Math.round(g * 255) << 8) + Math.round(b * 255)).toString(16).slice(1);
    }
  
    function render(time) {
      resizeCanvasToDisplaySize(gl.canvas);
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);
  
      gl.useProgram(program);
      gl.enableVertexAttribArray(positionAttributeLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
  
      gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
      gl.uniform1f(timeUniformLocation, time * 0.001 * speed);
      gl.uniform1f(iterationsUniformLocation, iterations);
      gl.uniform1f(colorShiftUniformLocation, colorShift);
      gl.uniform1f(zoomUniformLocation, zoom);
      gl.uniform3fv(color1UniformLocation, color1);
      gl.uniform3fv(color2UniformLocation, color2);
      gl.uniform3fv(color3UniformLocation, color3);
      gl.uniform3fv(color4UniformLocation, color4);
      gl.uniform1f(mirrorsUniformLocation, mirrors);
  
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
      requestAnimationFrame(render);
    }
  
    requestAnimationFrame(render);
  
    const toggleMenu = document.getElementById('toggleMenu');
    const customizeMenu = document.getElementById('customizeMenu');
    const closeMenuButton = document.getElementById('closeMenu');
    const speedSlider = document.getElementById('speed');
    const iterationsSlider = document.getElementById('iterations');
    const colorShiftSlider = document.getElementById('colorShift');
    const zoomSlider = document.getElementById('zoom');
    const mirrorsSlider = document.getElementById('mirrors');
    const color1Picker = document.getElementById('color1');
    const color2Picker = document.getElementById('color2');
    const color3Picker = document.getElementById('color3');
    const color4Picker = document.getElementById('color4');
    const randomizeButton = document.getElementById('randomizeButton');
  
    toggleMenu.addEventListener('click', () => {
      const isVisible = customizeMenu.style.display === 'block';
      customizeMenu.style.display = isVisible ? 'none' : 'block';
    });
    // Close the menu using the close button
    closeMenuButton.addEventListener('click', () => {
      customizeMenu.style.display = 'none';
    });


  
    speedSlider.addEventListener('input', (e) => {
      speed = parseFloat(e.target.value);
    });
  
    iterationsSlider.addEventListener('input', (e) => {
      iterations = parseInt(e.target.value);
    });
  
    colorShiftSlider.addEventListener('input', (e) => {
      colorShift = parseFloat(e.target.value);
    });
  
    zoomSlider.addEventListener('input', (e) => {
      zoom = parseFloat(e.target.value);
    });
  
    mirrorsSlider.addEventListener('input', (e) => {
      mirrors = parseInt(e.target.value);
    });
  
    color1Picker.addEventListener('input', (e) => {
      color1 = hexToRgb(e.target.value);
    });
  
    color2Picker.addEventListener('input', (e) => {
      color2 = hexToRgb(e.target.value);
    });
  
    color3Picker.addEventListener('input', (e) => {
      color3 = hexToRgb(e.target.value);
    });
  
    color4Picker.addEventListener('input', (e) => {
      color4 = hexToRgb(e.target.value);
    });
  
    function randomizeShader() {
      speed = Math.random() * 1.0;  
      iterations = Math.floor(Math.random() * 6) + 3;  
      colorShift = 0.3 + Math.random() * 0.7;  
      zoom = 0.8 + Math.random() * 0.8;  
      mirrors = Math.floor(Math.random() * 12) + 4;  
      
      let hue = Math.random();
      color1 = HSVtoRGB(hue, 0.5, 1.0);
      color2 = HSVtoRGB((hue + 0.2) % 1.0, 0.7, 0.8);
      color3 = HSVtoRGB((hue + 0.5) % 1.0, 0.3, 1.0);
      color4 = HSVtoRGB((hue + 0.7) % 1.0, 0.8, 0.6);
  
      speedSlider.value = speed;
      iterationsSlider.value = iterations;
      colorShiftSlider.value = colorShift;
      zoomSlider.value = zoom;
      mirrorsSlider.value = mirrors;
      color1Picker.value = rgbToHex(...color1);
      color2Picker.value = rgbToHex(...color2);
      color3Picker.value = rgbToHex(...color3);
      color4Picker.value = rgbToHex(...color4);
    }
  
    randomizeButton.addEventListener('click', randomizeShader);
  
    function HSVtoRGB(h, s, v) {
      let r, g, b;
      let i = Math.floor(h * 6);
      let f = h * 6 - i;
      let p = v * (1 - s);
      let q = v * (1 - f * s);
      let t = v * (1 - (1 - f) * s);
      switch (i % 6) {
          case 0: r = v, g = t, b = p; break;
          case 1: r = q, g = v, b = p; break;
          case 2: r = p, g = v, b = t; break;
          case 3: r = p, g = q, b = v; break;
          case 4: r = t, g = p, b = v; break;
          case 5: r = v, g = p, b = q; break;
      }
      return [r, g, b];
    }
  </script>
  </body>
  </html>